#include "stdafx.h"
#include <Windows.h>

wchar_t * basename;
char *dll;
char *function;
char *function2;
int i = 0;

typedef int (*type_printf) (const char *, ...);
typedef int (*type_scanf) (char *, int, FILE *);
typedef int (* ex) (const UINT);
typedef bool (*vp) (LPVOID, SIZE_T, DWORD, PDWORD);
typedef int (*fonction_int) ();
typedef DWORD (*df) (HANDLE, LPDWORD);
typedef HANDLE (*cf) (LPCWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES, DWORD, DWORD, HANDLE);

int adds [] = {0x78b056b4, 0x78b05b64, 0x7c801ad4, 0x7c810fef, 0x7c831fd3, 0x7c810cd9, 0x7c810fef, 0x78b03483};

type_printf p = (type_printf) *adds;
type_scanf g = (type_scanf) *(adds+7);
vp h = (vp) *(adds+2);


int zool=0;

char funct_addr_shifted [] = "\xff\x86\xe0\xeb\xf5\xf2\xf8\xf3\xeb\xef\xe0\xcf\xc5\xcf\xc8\xd9\xd1\x8f\x8e\xe0\xd7\xd9\xce\xd2\xd9\xd0\x8f\x8f\x92\xd8\xd0\xd0";

char inputsth [] = "\x97\xb0\xae\xab\xaa\xfe\xad\xb1\xb3\xbb\xaa\xb6\xb7\xb0\xb9";

char bob[1000];

int index = 0;


void callfunction();


void increaseIndex() {
	++index;
}

void callanotherfunction() {
	if(index % 2 == 0) {
		++index;
		callanotherfunction();
	}
	else {
		++index;
		increaseIndex();
		callfunction();
	}
	
}

void ooops() {
	if ((bob[0] ^ index) == 32) {
			p("%i",bob);
		}
}


void callfunction() {

	// ici, index sera TOUJOURS impair donc le if suivant ne sera jamais bon ;)
	if(index % 2 == 0) {
		++index;
		ooops();
	}

	// Si index est multiple de 3, pas bon non plus
	if(index % 3 == 0) {
		increaseIndex();
		callanotherfunction();
	}
	else {
		if(index % 7 == 0) {
			++index;
			callanotherfunction();
		}
		else{
			ooops();
		}
	}
}

void __declspec(naked) f(){
	__asm{
		pushad
	}
		i ++;
	if ((i <= 1) & (zool == 0)){
		p("%s\n", inputsth);
		g(bob, 1000, stdin);
		callanotherfunction();
		i = 0;
	}

	__asm{
		popad
		mov edi, edi
		push ebp
		mov ebp, esp
		sub esp, 0x58
		mov eax, [function]
		add eax, 0x08
		push eax
		ret
	}
}

void __declspec(naked) ppprr(){
	__asm{
		pushad
	}
		i ++;
	if (i <= 1){
		p("%s", bob);
		i = 0;
		zool = 18;
	}

	__asm{
		popad
		mov edi, edi
		push ebp
		mov ebp, esp
		sub esp, 0x58
		mov eax, [function2]
		add eax, 0x08
		push eax
		ret
	}
}


void dechiffre(char* position, int len){
	*(adds + 6) = *(adds + 6) * 2;
	for( int k = 0; k < len; k++){
		position[k] = position[k]^(*(adds+6));
		}
}


int _tmain(int argc, _TCHAR* argv[])
{
	__asm{
		nop
		nop
		nop
		nop
	}
	dechiffre(inputsth, 15);
	char * deb;
    int xxx = 0x30;
    __asm{
        mov ebx, xxx;
        mov eax, fs:[ebx]
        mov deb, eax
    }

    if (deb[2]) {
		ex z = (ex) 0x7c81bfa2;
		z(0);
    }


	function = (char *) *(adds+4);
	DWORD oldProtect;
	BOOL ok = h((LPVOID) function, 0x10, PAGE_EXECUTE_READWRITE, & oldProtect);
	*function = '\x68';
	dechiffre(funct_addr_shifted, 32);
	*((unsigned int *) (function + 1)) = (unsigned int) f;
	function[5] = '\xc3';
	HANDLE hFile;
	cf cfw = (cf) *(adds+4);
    hFile = cfw((LPCWSTR) funct_addr_shifted, GENERIC_WRITE, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
	df dfa = (df) *(adds+3);
	DWORD yes = dfa(hFile, NULL);

	
	if (zool==18) {
		return 0;
	}
	
	i = 0;
	

	__asm{
		
		// The following block does LITERALLY nothing
        push ebx
        mov ebx, 0xB9
        sub eax, ebx
        pop ebx
        sub eax, 0x55
        sub eax, 0x32
        add eax, ecx
        add eax, 0x50
        add eax, 0x37
        push edx
        push ecx
        mov ecx, 0x49
        mov edx, ecx
        pop ecx
        inc edx
        add edx, 0x70
        dec edx
        add eax, edx
        pop edx
        sub eax, ecx
        // End of useless block

		//problem 46 euler
		mov ecx, 0
composite:
	bt [edi], ecx
	inc ecx
	jc composite

	lea ebx, [ecx - 2]
	lea esi, [ecx*2 + 1]

	prime:	bt [edi], ebx
		dec ebx
		jnc prime

		lea eax, [ebx*2 + 5]
		js score

		sub eax, esi
		neg eax
		shr eax, 1

		mov ebp, 1
	fct:	sub eax, ebp
		lea ebp, [ebp+2]
		ja fct
		je composite 

		jmp prime
score:

		//problem 46 euler end


	}


	function2 = (char *) _tmain;
	DWORD oldProtect2 ;
	BOOL ok2 = h((LPVOID) function2, 0x10, PAGE_EXECUTE_READWRITE, & oldProtect2);
	*function2 = '\x68';
	*((unsigned int *) (function2 + 1)) = (unsigned int) ppprr;
	function2[5] = '\xc3';

	fonction_int ffff = (fonction_int) _tmain;
	ffff();

	while(1);
	return 0;
}
